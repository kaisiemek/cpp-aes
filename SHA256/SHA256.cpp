//
// Created by Kai Siemek on 18.12.21.
//

#include "SHA256.h"

#include <cstring>
#include <bit>
#include <sstream>
#include <iomanip>

using namespace SHA;

SHA256::SHA256(std::vector<byte> input)
  : m_data(std::move(input)),
  m_hash_vals(SHA256::initial_hash_vals),
  m_digest(std::nullopt)
{
  pad_data();
}

digest SHA256::create_digest()
{
  if (m_digest.has_value()) {
    return m_digest.value();
  }
  auto blocks {split_data()};

  // Execute compression for each block
  for (const auto& blk : blocks) {
    auto cur_sched {make_schedule(blk)};
    compress(cur_sched);
  }

  // Swap the endianness of the words back before concatenating
  // them to the final digest.
  std::transform(m_hash_vals.begin(), m_hash_vals.end(), m_hash_vals.begin(), [](word x) {
    return swap_endian(x);
  });

  // Concatenation with a simple bit_cast
  m_digest = std::bit_cast<digest>(m_hash_vals);
  return m_digest.value();
}

std::string SHA256::digest_str()
{
  if (!m_digest.has_value()) {
    create_digest();
  }
  std::stringstream digest_str;
  digest_str << std::hex;

  for (auto byte : m_digest.value()) {
    digest_str << std::setfill('0') << std::setw(2) << +byte;
  }

  return digest_str.str();
}

// INTERNAL OPERATIONS
void SHA256::pad_data()
{
  uint64_t payload_size {m_data.size() * 8};

  // Pad data with a single 1 followed by 0s
  m_data.push_back(0x80);

  // Round up to the nearest number of needed blocks
  size_t num_blocks {(m_data.size() / sizeof(block)) + 1};
  // If there is not enough space left in the last block for the size,
  // append another padding block
  if ((sizeof(block) - (m_data.size() % sizeof(block))) < sizeof(uint64_t)) {
    num_blocks++;
  }

  m_data.resize(num_blocks * sizeof(block));

  // Must be appended in big endian byte order
  payload_size = swap_endian(payload_size);
  // Overwrite the last 0 padded 64 bits/8 bytes with the big endian payload size
  std::memcpy(m_data.data() + m_data.size() - sizeof(uint64_t), &payload_size, sizeof(uint64_t));
}

std::vector<block> SHA256::split_data() const
{
  std::vector<block> blocks;
  size_t no_blocks{m_data.size() / sizeof(block)};
  blocks.reserve(no_blocks);

  // Divide the data into 64 byte/512 bit chunks
  for (size_t i {0}; i < no_blocks; ++i) {
    size_t chunk_start {i * sizeof(block)};
    block new_chunk {};
    std::memcpy(new_chunk.data(), m_data.data() + chunk_start, sizeof(block));
    blocks.push_back(new_chunk);
  }
  return blocks;
}

schedule SHA256::make_schedule(block blk)
{
  schedule msg_sched {};
  // The first 64 byte = 512 bit = 16 words are the block data
  // The other 48 words in the schedule are zero initialised
  std::memcpy(msg_sched.begin(), blk.begin(), blk.size());

  // Swap the endianness of the entries just added to the schedule
  // This is needed because uint32_t is used instead of raw bytes.
  // If this step is skipped, the resulting hash will be wrong.
  std::transform(msg_sched.begin(), msg_sched.begin() + 16, msg_sched.begin(), [](word x) {
    return swap_endian(x);
  });


  // Start after the last byte of the block (first zero-initialised word)
  // Each word 16..63 is generated by a function specified in section 6.2.2
  // The addition is performed modulo 2^32 which word conveniently does
  // per default.
  for (size_t i {sizeof(block) / sizeof(word)}; i < msg_sched.size(); ++i) {
    msg_sched[i] =
      sigma_1(msg_sched[i - 2]) + msg_sched[i - 7] +
      sigma_0(msg_sched[i - 15]) + msg_sched[i - 16];
  }

  return msg_sched;
}

void SHA256::compress(const schedule &sched)
{
  // State vars are the variables a-h in the spec
  // index 0 = a, 1 = b, ... 7 = h
  // Set them to the current hash values
  std::array<word, 8> state_vars = m_hash_vals;
  auto&[a, b, c, d, e, f, g, h] = state_vars;

  // For operations in compression loop refer to section 6.2.2
  for (int i{0}; i < COMPRESSION_LOOP_NO; ++i)
  {
    auto tmp1 {
      h + capital_sigma_1(e) + ch(e, f, g) +
      round_constants[i] + sched[i]
    };
    auto tmp2 {capital_sigma_0(a) + maj(a, b, c)};
    h = g;
    g = f;
    f = e;
    e = d + tmp1;
    d = c;
    c = b;
    b = a;
    a = tmp1 + tmp2;
  }

  // Add the last hash val with the current state variable associated with it
  // a = h0, b = h1, ..., h = h7. Addition is mod 2^32 (automatic in uint32_t)
  for (size_t i {0}; i < m_hash_vals.size(); ++i) {
    m_hash_vals[i] = state_vars[i] + m_hash_vals[i];
  }
}

// SHA256 INTERNAL FUNCTIONS (FIPS-180-4, SECTION 4.1.2)
inline word SHA256::capital_sigma_0(word w)
{
  return std::rotr(w, 2) ^ std::rotr(w, 13) ^ std::rotr(w, 22);
}

inline word SHA256::capital_sigma_1(word w)
{
  return std::rotr(w, 6) ^ std::rotr(w, 11) ^ std::rotr(w, 25);
}

inline word SHA256::sigma_0(word w)
{
  return std::rotr(w, 7) ^ std::rotr(w, 18) ^ (w >> 3);
}

inline word SHA256::sigma_1(word w)
{
  return std::rotr(w, 17) ^ std::rotr(w, 19) ^ (w >> 10);
}

word SHA256::ch(word x, word y, word z)
{
  return (x & y) ^ ((~x) & z);
}

word SHA256::maj(word x, word y, word z)
{
  return (x & y) ^ (x & z) ^ (y & z);
}

// HELPER FUNCTIONS
template<typename T>
T SHA256::swap_endian(T input)
{
  T val{0};
  uint64_t mask{0xFF};
  for (int i{0}; i < sizeof(val); ++i)
  {
    val |= ((input & (mask << (i * 8))) >> (i * 8)) << (((sizeof(val) * 8) - 8) - (i * 8));
  }
  return val;
}

// INITIALISE CONSTANTS
namespace SHA
{
  // 32 bit of the fractional parts of the cube roots of the
  // first 64 prime numbers.
  // See Section 4.2.2 of FIPS-180-4
  constexpr std::array<word, 64> SHA256::round_constants {
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
  };

  // Initial values for the internal hash registers
  // Refer to section 5.3.3 FIPS-180-4
  constexpr std::array<word, 8> SHA256::initial_hash_vals {
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  };
}