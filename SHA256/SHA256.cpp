//
// Created by Kai Siemek on 18.12.21.
//

#include "SHA256.h"

#include <sstream>
#include <cstring>
#include <bit>
#include <iomanip>
#include <iostream>
#include <bitset>

using namespace SHA;

void SHA256::pad_data()
{
  // Take the individual bytes of the data size in bits and reverse it -> big endian
  uint64_t payload_size {m_data.size() * 8};
  auto size_bytes = std::vector<uint8_t>(sizeof(uint64_t));
  std::memcpy(size_bytes.data(), &payload_size, size_bytes.size());
  // Only works on little endian platforms!
  std::reverse(size_bytes.begin(), size_bytes.end());

  // Pad data with a single 1 followed by 0s
  m_data.emplace_back(0x80);

  // Pad the data until it is a multiple of 512 - 64 (64 Bits for length)
  // Not very efficient, but readable and easy to follow
  // More efficient implementation could use std::memcpy.
  while (m_data.size() % (512 / 8) != (448 / 8)) {
    m_data.emplace_back(0x00);
  }

  // Append the big endian original payload size to the end of the padded data
  for (auto b : size_bytes) {
    m_data.push_back(b);
  }
}

std::string SHA256::to_str()
{
  std::stringstream data_str;
  int count {0};

  for (auto b : m_data) {
    count++;
    data_str << std::hex << std::uppercase << std::setfill('0') << std::setw(2) << +b;
    if ((count % 4) == 0) {
      data_str << ' ';
    }
  }

  return data_str.str();
}

void SHA256::chunk_data()
{
  using std::array, std::vector;

  size_t no_chunks {m_data.size() / sizeof(block)};
  m_blocks.clear();
  m_blocks.reserve(no_chunks);

  // Divide the data into 64 byte = 512 bit chunks
  for (size_t i {0}; i < no_chunks; ++i) {
    size_t chunk_start {i * sizeof(block)};
    block new_chunk {};
    std::memcpy(new_chunk.data(), m_data.data() + chunk_start, sizeof(block));
    m_blocks.push_back(new_chunk);
  }
}

schedule SHA256::create_message_schedule(block ch)
{
  schedule msg_schedule {};
  // The first 64 byte = 512 bit = 16 words are the block data
  // The other 48 words in the schedule are zero initialised
  std::memcpy(msg_schedule.data(), ch.data(), sizeof(block));

  // Start after the last byte of the block (first zero-initialised word)
  // Each word 16..63 is generated by a function specified in section 6.2.2
  // The addition is performed modulo 2^32, which is defined as operator+
  for (size_t i {sizeof(block) / sizeof(word)}; i < msg_schedule.size(); ++i) {
    msg_schedule[i] = sigma_1(msg_schedule[i - 2]) + msg_schedule[i - 7] + sigma_0(msg_schedule[i - 15]) + msg_schedule[i - 16];
  }

  return msg_schedule;
}

// SHA256 INTERNAL FUNCTIONS (FIPS-180-4, SECTION 4.1.2)
inline word SHA256::capital_sigma_0(word w)
{
  return rotr(w, 2) ^ rotr(w, 13) ^ rotr(w, 22);
}

inline word SHA256::capital_sigma_1(word w)
{
  return rotr(w, 6) ^ rotr(w, 11) ^ rotr(w, 25);
}

inline word SHA256::sigma_0(word w)
{
  return rotr(w, 7) ^ rotr(w, 18) ^ shr(w, 3);
}

inline word SHA256::sigma_1(word w)
{
  return rotr(w, 17) ^ rotr(w, 19) ^ shr(w, 10);
}

word SHA256::rotr(word w, int n)
{
  // Don't ask, yes this ridiculous thing seems to be necessary
  // for the correct bit order. Little endianness and the lack
  // of a std::byte equivalent for words/32 bit values makes this
  // basically impossible without flipping endianness or implementing
  // the right shift byte-wise which seemed more convoluted to me.
  auto val {flip_endianness(std::bit_cast<uint32_t>(w))};
  val = flip_endianness(std::rotr(val, n));
  return std::bit_cast<word>(val);
}

word SHA256::shr(word w, int n)
{
  // See comment above in rotr
  auto val {flip_endianness(std::bit_cast<uint32_t>(w))};
  val = flip_endianness(val >> n);
  return std::bit_cast<word>(val);
}

std::string SHA256::to_block_str() const
{
  std::stringstream block_str;

  for (int blk {0}; blk < m_blocks.size(); ++blk) {
    block_str << "CHUNK " << blk << "\n";
    for (int b {0}; b < m_blocks[blk].size(); ++b) {
      block_str << std::bitset<8>(m_blocks[blk][b]);
      if ((b + 1) % 8 == 0) {
        block_str << "\n";
      } else if ((b + 1) % 4 == 0) {
        block_str << " ";
      }
    }
  }

  return block_str.str();
}

std::string SHA256::make_schedule_str(int block_no) const
{
  std::stringstream sched_str;
  auto sched = create_message_schedule(m_blocks.at(block_no));

  int count {0};
  for (const auto& w : sched) {
    ++count;
    for (auto b : w) {
      sched_str << std::bitset<8>(b);
    }
    if (count % 2 == 0) {
      sched_str << "\n";
    } else {
      sched_str << " ";
    }
  }
  return sched_str.str();
}

digest SHA256::compress(const schedule& sched)
{
  static constexpr std::array<uint32_t, 8> initial_values {
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  };
  static constexpr auto make_word = [](uint32_t x) { return std::bit_cast<word>(flip_endianness(x)); };

  std::array<word, 8> hash_values{};
  std::transform(initial_values.begin(), initial_values.end(), hash_values.begin(), make_word);

  auto a{hash_values[0]};
  auto b{hash_values[1]};
  auto c{hash_values[2]};
  auto d{hash_values[3]};
  auto e{hash_values[4]};
  auto f{hash_values[5]};
  auto g{hash_values[6]};
  auto h{hash_values[7]};

  for (int i{0}; i < 64; ++i)
  {
    auto tmp1 {h + capital_sigma_1(e) + ch(e, f, g) + round_constants[i] + sched[i]};
    auto tmp2 {capital_sigma_0(a) + maj(a, b, c)};
    h = g;
    g = f;
    f = e;
    e = d + tmp1;
    d = c;
    c = b;
    b = a;
    a = tmp1 + tmp2;
  }

  hash_values[0] = a + hash_values[0];
  hash_values[1] = b + hash_values[1];
  hash_values[2] = c + hash_values[2];
  hash_values[3] = d + hash_values[3];
  hash_values[4] = e + hash_values[4];
  hash_values[5] = f + hash_values[5];
  hash_values[6] = g + hash_values[6];
  hash_values[7] = h + hash_values[7];

  return std::bit_cast<digest>(hash_values);
}

word SHA256::ch(word x, word y, word z)
{
  return (x & y) ^ ((~x) & z);
}

word SHA256::maj(word x, word y, word z)
{
  return (x & y) ^ (x & z) ^ (y & z);
}
